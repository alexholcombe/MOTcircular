ccopy_reg
_reconstructor
p1
(cpsychopy.data
TrialHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'origin'
p6
Vfrom __future__ import print_function\u000a__author__ = """Alex "O." Holcombe, Wei-Ying Chen""" ## double-quotes will be silently removed, single quotes will be left, eg, O'Connor\u000aimport helpersAOH\u000afrom psychopy import *\u000aimport psychopy.info\u000afrom psychopy import sound, monitors, logging\u000aimport numpy as np\u000aimport itertools #to calculate all subsets\u000afrom copy import deepcopy\u000afrom math import atan, pi, cos, sin, sqrt, ceil\u000aimport time, sys, platform, os, StringIO, gc\u000afrom EyelinkEyetrackerForPsychopySUPA3 import EyeLinkCoreGraphicsPsychopy, Tracker_EyeLink #Chris Fajou integration\u000afrom helpersAOH import accelerateComputer, openMyStimWindow, constructThickThinWedgeRingsTargetAndCue\u000aeyetracking = False\u000a\u000aquitFinder = True\u000aif quitFinder:\u000a    applescript="\u005c'tell application \u005c"Finder\u005c" to quit\u005c'" #quit Finder.\u000a    shellCmd = 'osascript -e '+applescript\u000a    os.system(shellCmd)\u000aprocess_priority = 'realtime' # 'normal' 'high' or 'realtime'\u000adisable_gc = True\u000a\u000asubject='test'#'test'\u000aautoLogging = False\u000ademo = False\u000aautopilot=True\u000aif autopilot:  subject='auto'\u000afeedback=True\u000aexportImages= False #quits after one trial / output image\u000ascreenshot= False; screenshotDone = False;allowGUI = False;waitBlank = False\u000atrackAllIdenticalColors = True#with tracking, can either use same colors as other task (e.g. 6 blobs but only 3 colors so have to track one of 2) or set all blobs identical color\u000a\u000atimeAndDateStr = time.strftime("%d%b%Y_%H-%M", time.localtime()) \u000arespTypes=['order']; respType=respTypes[0]\u000abindRadiallyRingToIdentify=1 #0 is inner, 1 is outer\u000agratingTexPix=1024#numpy textures must be a power of 2. So, if numColorsRoundTheRing not divide without remainder into textPix, there will be some rounding so patches will not all be same size\u000a\u000anumRings=2\u000aradii=[25]   #Need to encode as array for those experiments wherein more than one ring presented \u000aoffsets = np.array([[0,0],[-5,0],[-10,0]])\u000a\u000arespRadius=radii[0] #deg\u000arefreshRate= 60 *1.0;  #160 #set to the framerate of the monitor\u000auseClock = True #as opposed to using frame count, which assumes no frames are ever missed\u000afullscr=0; scrn=0\u000a# create a dialog from dictionary \u000ainfoFirst = { 'Autopilot':autopilot, 'Check refresh etc':False, 'Screen to use':scrn, 'Fullscreen (timing errors if not)': fullscr, 'Screen refresh rate': refreshRate }\u000aOK = gui.DlgFromDict(dictionary=infoFirst, \u000a    title='MOT', \u000a    order=['Autopilot','Check refresh etc', 'Screen to use', 'Screen refresh rate', 'Fullscreen (timing errors if not)'], \u000a    tip={'Check refresh etc': 'To confirm refresh rate and that can keep up, at least when drawing a grating',\u000a            'Screen to use': '0 means primary screen, 1 means second screen'},\u000a    )\u000aif not OK.OK:\u000a    print('User cancelled from dialog box'); core.quit()\u000aautopilot = infoFirst['Autopilot']\u000acheckRefreshEtc = infoFirst['Check refresh etc']\u000ascrn = infoFirst['Screen to use']\u000aprint('scrn = ',scrn, ' from dialog box')\u000afullscr = infoFirst['Fullscreen (timing errors if not)']\u000arefreshRate = infoFirst['Screen refresh rate']\u000a\u000aif demo: refreshRate = 60. \u000atokenChosenEachRing= [-999]*numRings\u000atargetDur = 0.1\u000arampUpDur=0\u000arampUpFrames = refreshRate*rampUpDur\u000aballStdDev = 1.8\u000amouseChoiceArea = ballStdDev*0.8 # origin =1.3\u000aunits='deg' #'cm'\u000atimeTillReversalMin = 0.5 #0.5; \u000atimeTillReversalMax = 1.5# 1.3 #2.9\u000acolors_all = np.array([[1,-1,-1],[1,-1,-1]])\u000acueColor = np.array([1,1,1])\u000a#monitor parameters\u000awidthPix = 800 #1440  #monitor width in pixels\u000aheightPix =600  #900 #monitor height in pixels\u000amonitorwidth = 38.5 #28.5 #monitor width in centimeters\u000aviewdist = 57.; #cm\u000apixelperdegree = widthPix/ (atan(monitorwidth/viewdist) /np.pi*180)\u000abgColor = [-1,-1,-1] #black background\u000amonitorname = 'testMonitor' # 'mitsubishi' #in psychopy Monitors Center\u000aif exportImages:\u000a    fullscr=0; scrn=0\u000a    widthPix = 600; heightPix = 450\u000a    monitorwidth = 25.0\u000aif demo:    \u000a    scrn=0; fullscr=0\u000a    widthPix = 800; heightPix = 600\u000a    monitorname='testMonitor'\u000a    allowGUI = True\u000a    monitorwidth = 23#18.0\u000a\u000amon = monitors.Monitor(monitorname,width=monitorwidth, distance=viewdist)#fetch the most recent calib for this monitor\u000amon.setSizePix( (widthPix,heightPix) )\u000amyWin = openMyStimWindow(mon,widthPix,heightPix,bgColor,allowGUI,units,fullscr,scrn,waitBlank)\u000amyMouse = event.Mouse(visible = 'true',win=myWin)\u000amyWin.setRecordFrameIntervals(False)\u000a\u000atrialsPerCondition = 1 #default value\u000a\u000arefreshMsg2 = ''\u000aif not checkRefreshEtc:\u000a    refreshMsg1 = 'REFRESH RATE WAS NOT CHECKED'\u000a    refreshRateWrong = False\u000aelse: #checkRefreshEtc\u000a    runInfo = psychopy.info.RunTimeInfo(\u000a            # if you specify author and version here, it overrides the automatic detection of __author__ and __version__ in your script\u000a            #author='<your name goes here, plus whatever you like, e.g., your lab or contact info>',\u000a            #version="<your experiment version info>",\u000a            win=myWin,    ## a psychopy.visual.Window() instance; None = default temp window used; False = no win, no win.flips()\u000a            refreshTest='grating', ## None, True, or 'grating' (eye-candy to avoid a blank screen)\u000a            verbose=True, ## True means report on everything \u000a            userProcsDetailed=True  ## if verbose and userProcsDetailed, return (command, process-ID) of the user's processes\u000a            )\u000a    print('Finished runInfo- which assesses the refresh and processes of this computer')\u000a    refreshMsg1 = 'Median frames per second ='+ str( np.round(1000./runInfo["windowRefreshTimeMedian_ms"],1) )\u000a    refreshRateTolerancePct = 3\u000a    pctOff = abs( (1000./runInfo["windowRefreshTimeMedian_ms"]-refreshRate) / refreshRate)\u000a    refreshRateWrong =  pctOff > (refreshRateTolerancePct/100.)\u000a    if refreshRateWrong:\u000a        refreshMsg1 += ' BUT'\u000a        refreshMsg1 += ' program assumes ' + str(refreshRate)\u000a        refreshMsg2 =  'which is off by more than' + str(round(refreshRateTolerancePct,0)) + '%!!'\u000a    else:\u000a        refreshMsg1 += ', which is close enough to desired val of ' + str( round(refreshRate,1) )\u000a    myWinRes = myWin.size\u000a    myWin.allowGUI =True\u000a\u000amyWin.close() #have to close window to show dialog box\u000adlgLabelsOrdered = list() #new dialog box\u000amyDlg = gui.Dlg(title="object tracking experiment", pos=(200,400))\u000aif not autopilot:\u000a    myDlg.addField('Subject name :', subject, tip='or subject code')\u000a    dlgLabelsOrdered.append('subject')\u000amyDlg.addField('Trials per condition (default=' + str(trialsPerCondition) + '):', trialsPerCondition, tip=str(trialsPerCondition))\u000adlgLabelsOrdered.append('trialsPerCondition')\u000apctCompletedBreak = 50\u000amyDlg.addText(refreshMsg1, color='Black')\u000aif refreshRateWrong:\u000a    myDlg.addText(refreshMsg2, color='Red')\u000amsgWrongResolution = ''\u000aif checkRefreshEtc and (not demo) and (myWinRes != [widthPix,heightPix]).any():\u000a    msgWrongResolution = 'Instead of desired resolution of '+ str(widthPix)+'x'+str(heightPix)+ ' pixels, screen apparently '+ str(myWinRes[0])+ 'x'+ str(myWinRes[1])\u000a    myDlg.addText(msgWrongResolution, color='Red')\u000a    print(msgWrongResolution)\u000amyDlg.addText('Note: to abort press ESC at a trials response screen', color=[-1.,1.,-1.]) # color='DimGrey') color names stopped working along the way, for unknown reason\u000amyDlg.show()\u000aif myDlg.OK: #unpack information from dialogue box\u000a   thisInfo = myDlg.data #this will be a list of data returned from each field added in order\u000a   if not autopilot:\u000a       name=thisInfo[dlgLabelsOrdered.index('subject')]\u000a       if len(name) > 0: #if entered something\u000a         subject = name #change subject default name to what user entered\u000a       trialsPerCondition = int( thisInfo[ dlgLabelsOrdered.index('trialsPerCondition') ] ) #convert string to integer\u000a       print('trialsPerCondition=',trialsPerCondition)\u000a       logging.info('trialsPerCondition =',trialsPerCondition)\u000aelse: \u000a   print('User cancelled from dialog box.')\u000a   logging.flush()\u000a   core.quit()\u000a\u000aif os.path.isdir('.'+os.sep+'dataRaw'):\u000a    dataDir='dataRaw'\u000aelse:\u000a    print('"dataRaw" directory does not exist, so saving data in present working directory')\u000a    dataDir='.'\u000aexpname = ''\u000afileNameWithPath = dataDir+'/'+subject+ '_' + expname+timeAndDateStr\u000aif not demo and not exportImages:\u000a    saveCodeCmd = 'cp \u005c'' + sys.argv[0] + '\u005c' '+ fileNameWithPath + '.py'\u000a    os.system(saveCodeCmd)  #save a copy of the code as it was when that subject was run\u000a    logF = logging.LogFile(fileNameWithPath+'.log', \u000a        filemode='w',#if you set this to 'a' it will append instead of overwriting\u000a        level=logging.INFO)#errors, data and warnings will be sent to this logfile\u000aif demo or exportImages: \u000a  logging.console.setLevel(logging.ERROR)  #only show this level  messages and higher\u000alogging.console.setLevel(logging.WARNING) #DEBUG means set the console to receive nearly all messges, INFO is for everything else, INFO, EXP, DATA, WARNING and ERROR \u000aif refreshRateWrong:\u000a    logging.error(refreshMsg1+refreshMsg2)\u000aelse: logging.info(refreshMsg1+refreshMsg2)\u000alongerThanRefreshTolerance = 0.27\u000alongFrameLimit = round(1000./refreshRate*(1.0+longerThanRefreshTolerance),3) # round(1000/refreshRate*1.5,2)\u000aprint('longFrameLimit=',longFrameLimit,' Recording trials where one or more interframe interval exceeded this figure ', file=logF)\u000aprint('longFrameLimit=',longFrameLimit,' Recording trials where one or more interframe interval exceeded this figure ')\u000aif msgWrongResolution != '':\u000a    logging.error(msgWrongResolution)\u000a\u000amyWin = openMyStimWindow(mon,widthPix,heightPix,bgColor,allowGUI,units,fullscr,scrn,waitBlank)\u000aprint('Window opened')\u000amyMouse = event.Mouse(visible = 'true',win=myWin)\u000aprint('Mouse enabled')\u000arunInfo = psychopy.info.RunTimeInfo(\u000a        win=myWin,    ## a psychopy.visual.Window() instance; None = default temp window used; False = no win, no win.flips()\u000a        refreshTest='grating', ## None, True, or 'grating' (eye-candy to avoid a blank screen)\u000a        verbose=True, ## True means report on everything \u000a        userProcsDetailed=True  ## if verbose and userProcsDetailed, return (command, process-ID) of the user's processes\u000a        )\u000aprint('second window opening runInfo mean ms=',runInfo["windowRefreshTimeAvg_ms"],file=logF)\u000aprint('second window opening runInfo mean ms=',runInfo["windowRefreshTimeAvg_ms"])\u000alogging.info(runInfo)\u000alogging.info('gammaGrid='+str(mon.getGammaGrid()))\u000alogging.info('linearizeMethod='+str(mon.getLinearizeMethod()))\u000a\u000aeyeballRadius = 5\u000aeyeball = visual.Circle(myWin, radius=eyeballRadius, edges=32, fillColorSpace='rgb',fillColor = (1,0,1),autoLog=autoLogging) #to outline chosen options\u000a\u000agaussian = visual.PatchStim(myWin, tex='none',mask='gauss',colorSpace='rgb',size=ballStdDev,autoLog=autoLogging)\u000agaussian2 = visual.PatchStim(myWin, tex='none',mask='gauss',colorSpace='rgb',size=ballStdDev,autoLog=autoLogging)\u000aoptionChosenCircle = visual.Circle(myWin, radius=mouseChoiceArea, edges=32, fillColorSpace='rgb',fillColor = (1,0,1),autoLog=autoLogging) #to outline chosen options\u000aclickableRegion = visual.Circle(myWin, radius=0.5, edges=32, fillColorSpace='rgb',fillColor = (-1,1,-1),autoLog=autoLogging) #to show clickable zones\u000acirclePostCue = visual.Circle(myWin, radius=2*radii[0], edges=32, fillColorSpace='rgb',fillColor = (-.85,-.85,-.85),lineColor=(-1,-1,-1),autoLog=autoLogging) #visual postcue\u000a#referenceCircle allows visualisation of trajectory, mostly for debugging\u000areferenceCircle = visual.Circle(myWin, radius=radii[0], edges=32, fillColorSpace='rgb',lineColor=(-1,-1,1),autoLog=autoLogging) #visual postcue\u000a\u000ablindspotFill = 0 #a way for people to know if they move their eyes\u000aif blindspotFill:\u000a    blindspotStim = visual.PatchStim(myWin, tex='none',mask='circle',size=4.8,colorSpace='rgb',color = (-1,1,-1),autoLog=autoLogging) #to outline chosen options\u000a    blindspotStim.setPos([13.1,-2.7]) #AOH, size=4.8; pos=[13.1,-2.7] #DL: [13.3,-0.8]\u000afixatnNoise = True\u000afixSizePix = 20 #make fixation big so flicker more conspicuous\u000aif fixatnNoise:\u000a    checkSizeOfFixatnTexture = fixSizePix/4\u000a    nearestPowerOfTwo = round( sqrt(checkSizeOfFixatnTexture) )**2 #Because textures (created on next line) must be a power of 2\u000a    fixatnNoiseTexture = np.round( np.random.rand(nearestPowerOfTwo,nearestPowerOfTwo) ,0 )   *2.0-1 #Can counterphase flicker  noise texture to create salient flicker if you break fixation\u000a    fixation= visual.PatchStim(myWin, tex=fixatnNoiseTexture, size=(fixSizePix,fixSizePix), units='pix', mask='circle', interpolate=False, autoLog=autoLogging)\u000a    fixationBlank= visual.PatchStim(myWin, tex=-1*fixatnNoiseTexture, colorSpace='rgb',mask='circle',size=fixSizePix,units='pix',autoLog=autoLogging)\u000aelse:\u000a    fixation = visual.PatchStim(myWin,tex='none',colorSpace='rgb',color=(.9,.9,.9),mask='circle',units='pix',size=fixSizePix,autoLog=autoLogging)\u000a    fixationBlank= visual.PatchStim(myWin,tex='none',colorSpace='rgb',color=(-1,-1,-1),mask='circle',units='pix',size=fixSizePix,autoLog=autoLogging)\u000afixationPoint = visual.PatchStim(myWin,colorSpace='rgb',color=(1,1,1),mask='circle',units='pix',size=2,autoLog=autoLogging) #put a point in the center\u000a\u000arespText = visual.TextStim(myWin,pos=(0, -.8),colorSpace='rgb',color = (1,1,1),alignHoriz='center', alignVert='center', units='norm',autoLog=autoLogging)\u000aNextText = visual.TextStim(myWin,pos=(0, 0),colorSpace='rgb',color = (1,1,1),alignHoriz='center', alignVert='center', units='norm',autoLog=autoLogging)\u000aNextRemindPctDoneText = visual.TextStim(myWin,pos=(-.1, -.4),colorSpace='rgb',color= (1,1,1),alignHoriz='center', alignVert='center', units='norm',autoLog=autoLogging)\u000aNextRemindCountText = visual.TextStim(myWin,pos=(.1, -.5),colorSpace='rgb',color = (1,1,1),alignHoriz='center', alignVert='center', units='norm',autoLog=autoLogging)\u000a\u000astimList = []\u000aspeeds = np.array( [ 0.5 ]  )   #dont want to go faster than 2 because of blur problem\u000a#Set up the factorial design (list of all conditions)\u000afor numCuesEachRing in [ [1] ]:\u000a for numObjsEachRing in [ [8] ]: #First entry in each sub-list is num objects in the first ring, second entry is num objects in the second ring\u000a  for cueLeadTime in [.16]: # [.160, .700]:  #How long is the cue on prior to the eyeballs appearing\u000a      for speed in speeds:\u000a          for direction in [1.0]: # [-1.0,1.0]:\u000a            for targetAngleOffset in [-8,8]:\u000a                for objToCueQuadrant in range(4):\u000a                    stimList.append( {'numCuesEachRing':numCuesEachRing,'numObjsEachRing':numObjsEachRing,'targetAngleOffset':targetAngleOffset,\u000a                                                'cueLeadTime':cueLeadTime,'speed':speed,'objToCueQuadrant':objToCueQuadrant,'direction':direction} )\u000a#set up record of proportion correct in various conditions\u000atrials = data.TrialHandler(stimList,trialsPerCondition) #constant stimuli method\u000a                                #        extraInfo= {'subject':subject} )  #will be included in each row of dataframe and wideText. Not working in v1.82.01\u000a\u000anumRightWrongEachSpeed = np.zeros([ len(speeds), 2 ]); #summary results to print out at end\u000a#end setup of record of proportion correct in various conditions\u000a\u000atimeAndDateStr = time.strftime("%d%b%Y_%H-%M", time.localtime()) \u000alogging.info(  str('starting exp with name: "'+'MovingCue'+'" at '+timeAndDateStr)   )\u000alogging.info( 'numtrials='+ str(trials.nTotal)+' refreshRate='+str(refreshRate)      )\u000a\u000aprint(' numtrials=', trials.nTotal)\u000aprint('rampUpDur=',rampUpDur, ' targetDur=', targetDur, ' secs', file=logF);  \u000alogging.info('task='+'track'+'   respType='+respType)\u000alogging.info(   'radii=' + str(radii)   )\u000alogging.flush()\u000a\u000aRFcontourAmp= 0.0\u000aRFcontourFreq = 2.0\u000aRFcontourPhase = 0\u000adef RFcontourCalcModulation(angle,freq,phase): \u000a    modulation = sin(angle*freq + phase) #radial frequency contour equation, e.g. http://www.journalofvision.org/content/14/11/12.full from Wilkinson et al. 1998\u000a    return modulation\u000a\u000aampTemporalRadiusModulation = 0.0 # 1.0/3.0\u000aampModulatnEachRingTemporalPhase = np.random.rand(numRings) * 2*np.pi\u000adef xyThisFrameThisAngle(basicShape, radiiThisTrial, numRing, angle, thisFrameN, speed):\u000a    #period of oscillation should be in sec\u000a    periodOfRadiusModulation = 1.0/speed#so if speed=2 rps, radius modulation period = 0.5 s\u000a    r = radiiThisTrial[numRing]\u000a    timeSeconds = thisFrameN / refreshRate\u000a    modulatnPhaseRadians = timeSeconds/periodOfRadiusModulation * 2*pi + ampModulatnEachRingTemporalPhase[numRing]\u000a    def waveForm(phase,type):\u000a        if type=='sin':\u000a            return sin(modulatnPhaseRadians)\u000a        elif type == 'sqrWave':\u000a            ans = np.sign( sin(modulatnPhaseRadians) ) #-1 or 1. That's great because that's also sin min and max\u000a            if ans==0: ans = -1+ 2*round( np.random.rand(1)[0] ) #exception case is when 0, gives 0, so randomly change that to -1 or 1\u000a            return ans\u000a        else: print('Error! unexpected type in radiusThisFrameThisAngle')\u000a        \u000a    if basicShape == 'circle':\u000a        rThis =  r + waveForm(modulatnPhaseRadians,'sin') * r * ampTemporalRadiusModulation\u000a        rThis += r * RFcontourAmp * RFcontourCalcModulation(angle,RFcontourFreq,RFcontourPhase)\u000a        x = rThis*cos(angle)\u000a        y = rThis*sin(angle)\u000a    elif basicShape == 'square': #actual square-shaped trajectory. Could also add all the modulations to this, later\u000a            #Theta varies from 0 to 2pi. Instead of taking its cosine, I should just pretend it is linear. Map it to 0->1 with triangle wave\u000a            #Want 0 to pi to be -1 to 1\u000a            def triangleWave(period, phase):\u000a                   #triangle wave is in sine phase (starts at 0)\u000a                   y = -abs(phase % (2*period) - period) # http://stackoverflow.com/questions/1073606/is-there-a-one-line-function-that-generates-a-triangle-wave\u000a                   #y goes from -period to 0.  Need to rescale to -1 to 1 to match sine wave etc.\u000a                   y = y/period*2 + 1\u000a                   #Now goes from -1 to 1\u000a                   return y\u000a            x = r * triangleWave(pi,angle)\u000a            y = r * triangleWave(pi, (angle-pi/2)%(2*pi ))\u000a            #This will always describe a diamond. To change the shape would have to use vector rotation formula\u000a    else: print('Unexpected basicShape ',basicShape)\u000a    return x,y\u000a\u000adef angleChangeThisFrame(thisTrial, moveDirection, numRing, thisFrameN, lastFrameN):\u000a    angleMove = moveDirection[numRing]*thisTrial['direction']*thisTrial['speed']*2*pi*(thisFrameN-lastFrameN)/refreshRate\u000a    return angleMove\u000a\u000adef oneFrameOfStim(thisTrial,currFrame,cues,stimRings,target,clock,useClock,offsetXYeachRing):\u000a#defining a function to draw each frame of stim. So can call second time for tracking task response phase\u000a          if useClock: #Don't count on not missing frames. Use actual time.\u000a            t = clock.getTime()\u000a            n = round(t*refreshRate)\u000a          else:\u000a            n = currFrame\u000a          \u000a          if n<rampUpFrames:\u000a                contrast = cos( -pi+ pi* n/rampUpFrames  ) /2. +.5 #starting from -pi trough of cos, and scale into 0->1 range\u000a          else: contrast = 1\u000a          if n%2:\u000a            fixation.draw()#flicker fixation on and off at framerate to see when skip frame\u000a          else:\u000a            fixationBlank.draw()\u000a          fixationPoint.draw()\u000a          #draw cue\u000a          for numRing in range(len(cues)):\u000a            if n< thisTrial['cueLeadTime']: #keep cue moving\u000a                angleMove = angleChangeThisFrame(thisTrial, moveDirection, numRing, n, n-1)\u000a                cues[numRing].setOri(angleMove,operation='+',log=autoLogging)\u000a            else: pass #Time for target, cue will now be stationary\u000a            cueCurrAngle = cues[numRing].ori\u000a            cue.draw()\u000a          #draw eyeballs\u000a          if n >= thisTrial['cueLeadTime']*refreshRate: #also draw rings\u000a               for numRing in range(len(stimRings)):\u000a#                angleMove = angleChangeThisFrame(thisTrial, moveDirection, numRing, n, n-1)\u000a#                stimAngleEachRing[numRing] += angleMove*(isReversed[numRing])\u000a#                angleObject0 = angleIniEachRing[numRing] + eyeballsCurrAngleEachRing[numRing]\u000a                #    print('angleMove=',np.round(angleMove,2)*180/pi, ' angleObject0=',np.round(angleObject0,2)*180/pi)\u000a                #stimRings[numRing].setOri(stimAngle,log=autoLogging)\u000a                stimRings[numRing].draw()\u000a                #target.setOri(angleMove,operation='+',log=autoLogging)\u000a                \u000a               target.draw()\u000a#                if reversalNumEachRing[numRing] <= len(reversalTimesEachRing[numRing]): #haven't exceeded  reversals assigned\u000a#                    reversalNum = int(reversalNumEachRing[numRing])\u000a#                    if len( reversalTimesEachRing[numRing] ) <= reversalNum:\u000a#                        msg = 'You failed to allocate enough reversal times, reached ' +str(reversalNum)+ ' reversals at '+ str(reversalTimesEachRing[numRing][reversalNum-1]) + \u005c\u000a#                                  'and still going, current time ='+str(n/refreshRate)+' asking for time of next one, will assume no more reversals'\u000a#                        logging.error(msg)\u000a#                        print(msg)\u000a#                        nextReversalTime = 9999 #didn't allocate enough, will just not reverse any more\u000a#                    else: #allocated enough reversals\u000a#                        nextReversalTime = reversalTimesEachRing[numRing][ reversalNum ]\u000a#                    if n > refreshRate * nextReversalTime: #have now exceeded time for this next reversal\u000a#                        isReversed[numRing] = -1*isReversed[numRing]\u000a#                        reversalNumEachRing[numRing] +=1\u000a#                        \u000a#                    x,y = xyThisFrameThisAngle('circle',radii, numRing,angleThisObject,n,thisTrial['speed']) ########################################################\u000a#                    x += offsetXYeachRing[numRing][0]\u000a#                    y += offsetXYeachRing[numRing][1]\u000a\u000a          if blindspotFill:\u000a              blindspotStim.draw()\u000a          return cueCurrAngle\u000a# #######End of function definition that displays the stimuli!!!! #####################################\u000a\u000arespPromptText = visual.TextStim(myWin,pos=(0, -.2),colorSpace='rgb',color = (1,1,1),alignHoriz='center', alignVert='center', units='norm',autoLog=autoLogging)\u000arespPromptText.setText('Press A if the thin wedge is offset anticlockwise, or L if clockwise')\u000a\u000adef collectResponses(expStop): #Kristjansson&Holcombe cuing experiment\u000a    #draw the possible stimuli\u000a    #eyeball left, eyeball right, eyeball down, eyeball up\u000a    #draw something that represents clockwise \u000a    responsesNeeded = 1\u000a    responsesAutopilot = list(['A'])\u000a    for r in range(responsesNeeded):\u000a        responsesAutopilot.append('A')\u000a    respcount =0\u000a    \u000a    while respcount <responsesNeeded:\u000a        respPromptText.draw()\u000a        myWin.flip()\u000a        for key in event.getKeys():       #check if pressed abort-type key\u000a              key = key.upper()\u000a              if key in ['ESCAPE','Q']:\u000a                  expStop = True\u000a                  respcount += 1\u000a                  responses.append('X') #dummy response so dont' get error when try to record in datafile before quitting\u000a              elif key.upper() in ['A','L']: #A for anticlockwise, L for clockwise\u000a                   responses.append( key.upper() )\u000a                   respcount += 1\u000a              else: #flicker response prompt to indicate invalid response\u000a                for f in range(2):\u000a                    myWin.flip(); myWin.flip()\u000a                    respPromptText.draw()\u000a                    myWin.flip()\u000a        if autopilot:\u000a           respCount = responsesNeeded\u000a           break\u000a           \u000a    return responses,responsesAutopilot, expStop\u000a\u000atrialNum=0; numTrialsCorrect=0; expStop=False; framesSaved=0;\u000aprint('Starting experiment of',trials.nTotal,'trials. Current trial is trial ',trialNum)\u000aNextRemindCountText.setText( str(trialNum) + ' of ' + str(trials.nTotal)     )\u000aNextRemindCountText.draw()\u000amyWin.flip()\u000a#end of header\u000atrialClock = core.Clock()\u000astimClock = core.Clock()\u000athisTrial = trials.next()\u000ats = list();\u000a\u000aif eyetracking:\u000a    eyeMoveFile=('EyeTrack_'+subject+'_'+timeAndDateStr+'.EDF')\u000a    tracker=Tracker_EyeLink(myWin,trialClock,subject,1, 'HV5',(255,255,255),(0,0,0),False,(widthPix,heightPix))\u000a\u000awhile trialNum < trials.nTotal and expStop==False:\u000a    accelerateComputer(1,process_priority, disable_gc) #speed up\u000a    \u000a    numObjects = thisTrial['numObjsEachRing'][0] #haven't implemented additional rings yet\u000a    objsPerQuadrant = numObjects / 4\u000a    if numObjects % 4 != 0:\u000a        msg = 'numObjects not evenly divisible by 4, therefore cannot randomise quadrant. Therefore picking object to cue completely randomly'\u000a        logging.error(msg); print(msg)\u000a        objToCue = np.random.random_integers(0, numObjects-1, size=1)\u000a    else:\u000a        quadrantObjectToCue =  np.random.random_integers(0, objsPerQuadrant-1, size=1)\u000a        objToCue = thisTrial['objToCueQuadrant']*objsPerQuadrant + quadrantObjectToCue\u000a    #print('objToCue=',objToCue)\u000a    colorRings=list();\u000a    preDrawStimToGreasePipeline = list()\u000a    isReversed= list([1]) * numRings #always takes values of -1 or 1\u000a    reversalNumEachRing = list([0]) * numRings\u000a    angleIniEachRing = list( np.random.uniform(0,2*pi,size=[numRings]) )\u000a    cueCurrAngleEachRing = list([0]) * numRings\u000a    moveDirection = list( np.random.random_integers(0,1,size=[numRings]) *2 -1 ) #randomise initial direction\u000a    trialDurTotal = thisTrial['cueLeadTime'] + targetDur\u000a    trialDurFrames= int( trialDurTotal*refreshRate )\u000a    \u000a    #Task will be to judge which thick wedge has the thin wedge offset within it\u000a    #Set up parameters to construct the thick,thin wedges, target, and cue\u000a    gratingTexPix= 1024\u000a    radius = 25\u000a    visibleWedge = [0,360]\u000a    patchAngleThickWedges = 360/numObjects/2\u000a    thickWedgeColor = [0,-1,-1]\u000a    thinWedgeColor=[0,1,1]\u000a    cueColor=[0,1,1]\u000a    radialMask =   np.array( [0,0,0,0,0,0,0,1,0,0,0] )\u000a    wedgeRadiusFraction = np.where(radialMask)[0][0]*1.0 / len(radialMask)\u000a    #print('wedgeRadiusFraction = ',wedgeRadiusFraction)\u000a    wedgeThicknessFraction = len( np.where(radialMask)[0] )*1.0 / len(radialMask)\u000a    #print('wedgeThickness = ',wedgeThicknessFraction*radius)\u000a    wedgeCenterFraction = wedgeRadiusFraction + wedgeThicknessFraction/2.\u000a    desiredArcDistanceFractionRadius = .23\u000a    cueInnerArcDesiredFraction = wedgeCenterFraction - desiredArcDistanceFractionRadius\u000a    cueOuterArcDesiredFraction = wedgeCenterFraction + desiredArcDistanceFractionRadius\u000a    if cueOuterArcDesiredFraction > 1:\u000a        msg='Can"t start outer arc at fraction='+str(cueOuterArcDesiredFraction)\u000a        logging.error(msg); print(msg)\u000a    fractionResolution = .02     #Quantisation of possible positions of cue arc\u000a    binsNeeded = 1.0 / fractionResolution\u000a    cueRadialMask = np.zeros( binsNeeded )\u000a    #For the cueRadialMask, want everything zero except just inside and outside of the wedges.\u000a    innerArcCenterPos = round( binsNeeded*cueInnerArcDesiredFraction )\u000a    outerArcCenterPos = round( binsNeeded*cueOuterArcDesiredFraction )\u000a    cueRadialMask[ innerArcCenterPos ] = 1\u000a    cueRadialMask[ outerArcCenterPos ] = 1\u000a    thinWedgesAngleSubtend = 2\u000a    innerArcActualFraction = innerArcCenterPos*1.0/len(cueRadialMask)\u000a    outerArcActualFraction = outerArcCenterPos*1.0/len(cueRadialMask)\u000a    closeEnough = .01\u000a    if abs(cueInnerArcDesiredFraction - innerArcActualFraction) > closeEnough:\u000a        print('cueInnerArcDesiredFraction of object radius = ',cueInnerArcDesiredFraction, ' actual = ', innerArcActualFraction, ' exceeding tolerance of ',closeEnough )\u000a    if abs(cueOuterArcDesiredFraction - outerArcActualFraction) > closeEnough:\u000a        print('cueOuterArcDesiredFraction of object radius = ',cueOuterArcDesiredFraction, ' actual = ', outerArcActualFraction, ' exceeding tolerance of ',closeEnough)\u000a    thickThinWedgesRing, target, cue =  \u005c\u000a            constructThickThinWedgeRingsTargetAndCue(myWin,radii[0],radialMask,cueRadialMask,visibleWedge,numObjects,patchAngleThickWedges,\u000a                            thinWedgesAngleSubtend,bgColor,thickWedgeColor,thinWedgeColor,thisTrial['targetAngleOffset'],gratingTexPix,cueColor,objToCue,ppLog=logging)\u000a    core.wait(.1)\u000a    myMouse.setVisible(False)\u000a    if eyetracking: \u000a        tracker.startEyeTracking(trialNum,True,widthPix,heightPix) #start recording with eyetracker\u000a\u000a    fixatnPeriodFrames = int(   (np.random.rand(1)/2.+0.8)   *refreshRate)  #random interval between x and x+800ms\u000a    for i in range(fixatnPeriodFrames):\u000a        if i%2:\u000a            fixation.draw()\u000a        else: fixationBlank.draw()\u000a        myWin.flip() #clearBuffer=True)  \u000a    trialClock.reset()\u000a    t0=trialClock.getTime(); t=trialClock.getTime()-t0\u000a    ts = list()\u000a    stimClock.reset()\u000a    for n in range(trialDurFrames): #this is the loop for this trial's stimulus!\u000a            offsetXYeachRing=[[0,0],[0,0]]\u000a            cueAngle = \u005c\u000a                        oneFrameOfStim(thisTrial,n,[cue],[thickThinWedgesRing],target,stimClock,useClock,offsetXYeachRing) #actual drawing of stimuli\u000a            if exportImages:\u000a                myWin.getMovieFrame(buffer='back') #for later saving\u000a                framesSaved +=1\u000a            myWin.flip(clearBuffer=True)\u000a            t=trialClock.getTime()-t0; ts.append(t);\u000a    #event.waitKeys(maxWait=2, keyList=['SPACE'], timeStamped=False) #debugOFF\u000a    myWin.flip()\u000a    event.clearEvents(eventType='mouse')\u000a    if eyetracking:\u000a        tracker.stopEyeTracking()\u000a\u000a    #end of big stimulus loop\u000a    accelerateComputer(0,process_priority, disable_gc) #turn off stuff that sped everything up\u000a    #check for timing problems\u000a    interframeIntervs = np.diff(ts)*1000 #difference in time between successive frames, in ms\u000a    idxsInterframeLong = np.where( interframeIntervs > longFrameLimit ) [0] #frames that exceeded longerThanRefreshTolerance of expected duration\u000a    numCasesInterframeLong = len( idxsInterframeLong )\u000a    if numCasesInterframeLong >0:\u000a       longFramesStr =  'ERROR,'+str(numCasesInterframeLong)+' frames were longer than '+str(longFrameLimit)+' ms'\u000a       if demo: \u000a         longFramesStr += 'not printing them all because in demo mode'\u000a       else:\u000a           longFramesStr += ' apparently screen refreshes skipped, interframe durs were:'+\u005c\u000a                    str( np.around(  interframeIntervs[idxsInterframeLong] ,1  ) )+ ' and was these frames: '+ str(idxsInterframeLong)\u000a       if longFramesStr != None:\u000a                print('trialnum=',trialNum,'  ',longFramesStr)\u000a                print('trialnum=',trialNum,'  ',longFramesStr, file=logF)\u000a                if not demo:\u000a                    flankingAlso=list()\u000a                    for idx in idxsInterframeLong: #also print timing of one before and one after long frame\u000a                        if idx-1>=0:  flankingAlso.append(idx-1)\u000a                        else: flankingAlso.append(np.NaN)\u000a                        flankingAlso.append(idx)\u000a                        if idx+1<len(interframeIntervs):  flankingAlso.append(idx+1)\u000a                        else: flankingAlso.append(np.NaN)\u000a                    #print >>logF, 'flankers also='+str( np.around( interframeIntervs[flankingAlso], 1) )\u000a            #end timing check\u000a    myMouse.setVisible(True)\u000a    passThisTrial=False\u000a    \u000a    # ####### set up and collect responses\u000a    responses = list();  responsesAutopilot = list()\u000a    responses,responsesAutopilot, expStop =  \u005c\u000a            collectResponses(expStop)  #collect responses!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!#####\u000a    core.wait(.1)\u000a    if exportImages:  #maybe catch one frame of response\u000a        myWin.saveMovieFrames('exported/frame.png')    \u000a        expStop=True\u000a    #Handle response, calculate whether correct, ########################################\u000a    if autopilot:\u000a        responses = responsesAutopilot\u000a    #score response\u000a    if thisTrial['targetAngleOffset'] >0:\u000a        answer = 'L'\u000a    else:\u000a        answer = 'A'\u000a    if responses[0] == answer:\u000a        correct = 1\u000a    else: correct = 0            \u000a    if passThisTrial: \u000a        correct = -1    #indicate for data analysis that observer opted out of this trial, because think they moved their eyes\u000a    \u000a    #header print('trialnum\u005ctsubject\u005ctbasicShape\u005ctnumObjects\u005ctspeed\u005ctdirection\u005ctangleIni\u000a    trials.data.add('subject', subject) #because extraInfo not working\u000a    trials.data.add('objToCueRing0', objToCue[0])\u000a    trials.data.add('numObjsRing0', numObjsEachRing[0])\u000a    trials.data.add('numCuesRing0', numCuesEachRing[0])\u000a    trials.data.add('response', responses[0]) #switching to using psychopy-native ways of storing, saving data \u000a    trials.data.add('correct', correct) #switching to using psychopy-native ways of storing, saving data \u000a    trials.data.add('timingBlips', numCasesInterframeLong)\u000a    numTrialsCorrect += (correct >0)  #so count -1 as 0\u000a    speedIdxs = np.where(thisTrial['speed']==speeds)[0]\u000a    if len(speedIdxs) ==0:\u000a        print('Apparently current speed= ',thisTrial['speed'],' is not in list of speeds=',speeds, '. Please make sure speeds is a numpy array')\u000a    else: speedIdx = speedIdxs[0]  #extract index, where returns a list with first element array of the indexes\u000a    numRightWrongEachSpeed[ speedIdx, (correct >0) ] +=1  #if right, add to 1th column, otherwise add to 0th column count\u000a    \u000a    if feedback and not expStop:\u000a        if correct:\u000a            highA = sound.Sound('G',octave=5, sampleRate=6000, secs=.8, bits=8)\u000a            highA.setVolume(0.8)\u000a            highA.play()\u000a        else: #incorrect\u000a            lowD = sound.Sound('E',octave=3, sampleRate=6000, secs=.8, bits=8)\u000a            lowD.setVolume(0.8)\u000a            lowD.play()\u000a    trialNum+=1\u000a    waitForKeyPressBetweenTrials = False\u000a    if trialNum< trials.nTotal:\u000a        if trialNum%( max(trials.nTotal/4,1) ) ==0:  #have to enforce at least 1, otherwise will modulus by 0 when #trials is less than 4\u000a            pctDone = round(    (1.0*trialNum) / (1.0*trials.nTotal)*100,  0  )\u000a            NextRemindPctDoneText.setText( str(pctDone) + '% complete' )\u000a            NextRemindCountText.setText( str(trialNum) + ' of ' + str(trials.nTotal)     )\u000a            for i in range(5):\u000a                myWin.flip(clearBuffer=True)\u000a                NextRemindPctDoneText.draw()\u000a                NextRemindCountText.draw()\u000a        waitingForKeypress = False\u000a        if waitForKeyPressBetweenTrials:\u000a            waitingForKeypress=True\u000a            NextText.setText('Press "SPACE" to continue')\u000a            NextText.draw()\u000a            NextRemindCountText.draw()\u000a            NextRemindText.draw()\u000a            myWin.flip(clearBuffer=True) \u000a        else: core.wait(0.15)\u000a        while waitingForKeypress:\u000a           if autopilot:\u000a                waitingForKeypress=False\u000a           elif expStop == True:\u000a                waitingForKeypress=False\u000a           for key in event.getKeys():       #check if pressed abort-type key\u000a                 if key in ['space']: \u000a                    waitingForKeypress=False\u000a                 if key in ['escape','q']:\u000a                    expStop = True\u000a                    waitingForKeypress=False\u000a        myWin.clearBuffer()\u000a        thisTrial = trials.next()\u000a    core.wait(.1); time.sleep(.1)\u000a    #end trials loop  ###########################################################\u000aif expStop == True:\u000a    print('user aborted experiment on keypress with trials trialNum=', trialNum, file=logF)\u000a    print('user aborted experiment on keypress with trials trialNum=', trialNum)\u000aelse: \u000a    print("Experiment finished")\u000aif  trialNum >0:\u000a    fileNamePP = fileNameWithPath + '.txt'\u000a    dfFromPP = trials.saveAsWideText(fileNamePP)\u000a    print("Psychopy wideText has been saved as", fileNamePP)\u000a    fileNamePickle = fileNameWithPath #.psydat will automatically be appended\u000a    trials.saveAsPickle(fileNamePickle) #.psydat\u000a    print("Most Psychopy-ic method: trials trialHandler has been saved as", fileNamePickle+'.psydat', " and should include copy of code")\u000a    #see analysis/analyzeTest.py\u000a    #df.dtypes in my case are  "objects". you can't take the mean\u000a    df = dfFromPP\u000a\u000aif eyetracking:\u000a    tracker.closeConnectionToEyeTracker(eyeMoveFile)\u000aprint('finishing at ',timeAndDateStr, file=logF)\u000a#print('%corr = ', round( correct*1.0/trialNum*100., 2)  , '% of ',trialNum,' trials', end=' ')\u000aprint('%corr each speed: ', end=' ')\u000aprint(np.around( numRightWrongEachSpeed[:,1] / ( numRightWrongEachSpeed[:,0] + numRightWrongEachSpeed[:,1]), 2))\u000aprint('\u005ct\u005ct\u005ct\u005ctnum trials each speed =', numRightWrongEachSpeed[:,0] + numRightWrongEachSpeed[:,1])\u000afrom psychopy.misc import fromFile\u000a\u000alogging.flush()\u000aif quitFinder:\u000a        applescript="\u005c'tell application \u005c"Finder\u005c" to launch\u005c'" #turn Finder back on\u000a        shellCmd = 'osascript -e '+applescript\u000a        os.system(shellCmd)\u000a\u000a#Fit and plot data\u000aif trialNum >0:\u000a    import plotHelpers\u000a    fig = plotHelpers.plotDataAndPsychometricCurve(df, dataFileName=None)\u000a    figFnameWithPath = os.path.join('figures/', fName + '.png')\u000a    pylab.savefig( figFnameWithPath ) #, bbox_inches='tight')\u000a    print('The plot has been saved, as', figFnameWithPath)\u000a    pylab.show() #pauses until window manually closed. Have to save before calling this, because closing the window loses the figure\u000a
p7
sS'thisTrial'
p8
g1
(cpsychopy.data
TrialType
p9
c__builtin__
dict
p10
(dp11
S'direction'
p12
F1
sS'numObjsEachRing'
p13
(lp14
I8
asS'objToCueQuadrant'
p15
I2
sS'targetAngleOffset'
p16
I-8
sS'numCuesEachRing'
p17
(lp18
I1
asS'speed'
p19
cnumpy.core.multiarray
scalar
p20
(cnumpy
dtype
p21
(S'f8'
I0
I1
tRp22
(I3
S'<'
NNNI-1
I-1
I0
tbS'\x00\x00\x00\x00\x00\x00\xe0?'
tRp23
sS'cueLeadTime'
p24
F0.16
stRp25
sS'_exp'
p26
NsS'name'
p27
S''
sS'originPath'
p28
S'/Users/alexh/Documents/attention_tempresltn/multiple object tracking/newTraj/newTraj_repo/HolcombeKristjansson.py'
p29
sS'thisRepN'
p30
I0
sS'autoLog'
p31
I01
sS'extraInfo'
p32
NsS'data'
p33
g1
(cpsychopy.data
DataHandler
p34
g10
(dp35
S'numObjsRing0'
p36
cnumpy.ma.core
_mareconstruct
p37
(cnumpy.ma.core
MaskedArray
p38
cnumpy
ndarray
p39
(I0
tp40
S'b'
tRp41
(I1
(I8
I1
tg21
(S'f4'
I0
I1
tRp42
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x00A\x00\x00\x00A\x00\x00\x00A\x00\x00\x00A\x00\x00\x00A\x00\x00\x00A\x00\x00\x00A\x00\x00\x00A'
S'\x00\x00\x00\x00\x00\x00\x00\x00'
NtbsS'timingBlips'
p43
g37
(g38
g39
g40
S'b'
tRp44
(I1
(I8
I1
tg42
I00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x00\x00\x00\x00\x00\x00\x00'
NtbsS'ran'
p45
g37
(g38
g39
g40
S'b'
tRp46
(I1
(I8
I1
tg42
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00'
NtbsS'objToCueRing0'
p47
cnumpy.core.multiarray
_reconstruct
p48
(g39
(I0
tS'b'
tRp49
(I1
(I8
I1
tg21
(S'O4'
I0
I1
tRp50
(I3
S'|'
NNNI-1
I-1
I63
tbI00
(lp51
g20
(g21
(S'i4'
I0
I1
tRp52
(I3
S'<'
NNNI-1
I-1
I0
tbS'\x01\x00\x00\x00'
tRp53
ag20
(g52
S'\x03\x00\x00\x00'
tRp54
ag20
(g52
S'\x05\x00\x00\x00'
tRp55
ag20
(g52
S'\x07\x00\x00\x00'
tRp56
ag20
(g52
S'\x01\x00\x00\x00'
tRp57
ag20
(g52
S'\x03\x00\x00\x00'
tRp58
ag20
(g52
S'\x05\x00\x00\x00'
tRp59
ag20
(g52
S'\x06\x00\x00\x00'
tRp60
atbsS'response'
p61
g48
(g39
(I0
tS'b'
tRp62
(I1
(I8
I1
tg50
I00
(lp63
S'A'
aS'A'
aS'A'
aS'A'
aS'A'
aS'A'
aS'A'
aS'A'
atbsS'numCuesRing0'
p64
g37
(g38
g39
g40
S'b'
tRp65
(I1
(I8
I1
tg42
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?'
S'\x00\x00\x00\x00\x00\x00\x00\x00'
NtbsS'order'
p66
g37
(g38
g39
g40
S'b'
tRp67
(I1
(I8
I1
tg42
I00
S'\x00\x00\x80?\x00\x00\xa0@\x00\x00\xe0@\x00\x00\x00@\x00\x00\xc0@\x00\x00@@\x00\x00\x80@\x00\x00\x00\x00'
S'\x00\x00\x00\x00\x00\x00\x00\x00'
NtbsS'correct'
p68
g37
(g38
g39
g40
S'b'
tRp69
(I1
(I8
I1
tg42
I00
S'\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x80?\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x00\x00\x00\x00\x00\x00\x00'
NtbsS'subject'
p70
g48
(g39
(I0
tS'b'
tRp71
(I1
(I8
I1
tg50
I00
(lp72
S'auto'
p73
ag73
ag73
ag73
ag73
ag73
ag73
ag73
atbstRp74
(dp75
S'isNumeric'
p76
(dp77
g68
I01
sg36
I01
sg43
I01
sg45
I01
sg47
I00
sg61
I00
sg64
I01
sg66
I01
sg70
I00
ssS'trials'
p78
g4
sS'dataTypes'
p79
(lp80
g45
ag66
ag70
ag47
ag36
ag64
ag61
ag68
ag43
asS'dataShape'
p81
(lp82
I8
aI1
asbsS'method'
p83
S'random'
p84
sS'sequenceIndices'
p85
g48
(g39
(I0
tS'b'
tRp86
(I1
(I8
I1
tg52
I01
S'\x07\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x05\x00\x00\x00\x06\x00\x00\x00\x01\x00\x00\x00\x04\x00\x00\x00\x02\x00\x00\x00'
tbsS'finished'
p87
I00
sS'nReps'
p88
I1
sS'nRemaining'
p89
I0
sS'trialList'
p90
(lp91
g1
(g9
g10
(dp92
g12
F1
sg13
g14
sg15
I0
sg16
I-8
sg17
g18
sg19
g23
sg24
F0.16
stRp93
ag1
(g9
g10
(dp94
g12
F1
sg13
g14
sg15
I1
sg16
I-8
sg17
g18
sg19
g23
sg24
F0.16
stRp95
ag25
ag1
(g9
g10
(dp96
g12
F1
sg13
g14
sg15
I3
sg16
I-8
sg17
g18
sg19
g23
sg24
F0.16
stRp97
ag1
(g9
g10
(dp98
g12
F1
sg13
g14
sg15
I0
sg16
I8
sg17
g18
sg19
g23
sg24
F0.16
stRp99
ag1
(g9
g10
(dp100
g12
F1
sg13
g14
sg15
I1
sg16
I8
sg17
g18
sg19
g23
sg24
F0.16
stRp101
ag1
(g9
g10
(dp102
g12
F1
sg13
g14
sg15
I2
sg16
I8
sg17
g18
sg19
g23
sg24
F0.16
stRp103
ag1
(g9
g10
(dp104
g12
F1
sg13
g14
sg15
I3
sg16
I8
sg17
g18
sg19
g23
sg24
F0.16
stRp105
asS'seed'
p106
NsS'thisIndex'
p107
g20
(g52
S'\x02\x00\x00\x00'
tRp108
sS'thisN'
p109
I7
sS'thisTrialN'
p110
I7
sS'nTotal'
p111
I8
sS'_warnUseOfNext'
p112
I01
sb.